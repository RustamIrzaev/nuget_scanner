use std::fs::File;
use std::io::Write;
use clap::Parser;
use colored::Colorize;

use crate::cli::Cli;
use crate::models::package_info::PackageInfo;
use crate::services::convert_and_map_packages::convert_and_map_packages;
use crate::services::find_package_files::find_package_files;
use crate::utils::parse_configs::{parse_csproj, parse_packages_config};

mod cli;
mod models;
mod services;
mod utils;

fn main() {
    let args = Cli::parse();

    let folder = args.folder.to_string_lossy().to_string();
    let package_files = find_package_files(&folder, args.max_depth);

    let mut packages = Vec::new();

    for file in package_files {
        if file.ends_with("packages.config") {
            packages.extend(parse_packages_config(&file));
        } else if file.ends_with(".csproj") {
            packages.extend(parse_csproj(&file));
        }
    }

    if packages.is_empty() {
        println!("{}", "No NuGet packages found in the specified folder".bold().bright_red().to_string());
        return;
    }

    let package_data = convert_and_map_packages(packages);

    print_packages_info(&package_data);

    if args.report {
        generate_markdown_report(package_data, folder.clone());
    }
}

fn print_packages_info(package_data: &Vec<PackageInfo>) {
    for info in package_data {
        if info.is_parsed_ok {
            println!(
                "- {}, version {} {} {}",
                info.name.bold().bright_blue(),
                info.version.italic().bright_blue(),
                if info.is_outdated {
                    "[outdated]".bright_red()
                } else {
                    "".normal()
                },
                if info.is_outdated {
                    format!(" latest: {}", info.latest_version.bright_green())
                } else {
                    "".to_string()
                }
            );

            println!("  license: {}", info.license_expression.bright_yellow());
            println!("  license URL: {}", info.license_url.bright_purple());
            println!("  description: {}", info.description.bright_cyan());
            println!("  project URL: {}", info.project_url.bright_magenta());
            println!("  released at: {}", info.published_date.bright_cyan());
            println!();
        } else {
            println!(
                "- {}, version {}",
                info.name.bold().bright_blue(),
                info.version.italic().bright_blue()
            );
            println!(
                "  {}",
                "Unable to fetch package details".italic().red().to_string()
            );
            println!();
        }
    }
}

fn generate_markdown_report(package_data: Vec<PackageInfo>, save_folder_path: String) {
    let mut report = String::new();

    report.push_str("# NuGet Packages Report\n\n");
    // report.push_str("Project X\n");

    report.push_str("| Package Name | Version | Latest? | License | Description |\n");
    report.push_str(" | --- | --- | --- | --- | --- |\n");

    for info in package_data {
        if info.is_parsed_ok {
            let outdated = if info.is_outdated {
                format!("ðŸ”¸ {}", info.latest_version)
            } else {
                "âœ…".to_string()
            };

            report.push_str(&format!(
                "| **[{}]({})** | {} | {} | [{}]({}) | {}\n",
                info.name,
                info.project_url,
                info.version,
                outdated,
                info.license_expression,
                info.license_url,
                info.description
            ));
        } else {
            report.push_str(&format!(
                "| {} | {} | - | - | {}\n",
                info.name,
                info.version,
                "ðŸ›‘ error fetching details"
            ));
        }
    }

    report.push_str("\n---\n");
    report.push_str("_Generated by [nuget-scanner](https://github.com/RustamIrzaev/nuget_scanner)_");

    let report_path = format!("{}/LICENSE_REPORT.md", save_folder_path.clone());
    let mut file = File::create(&report_path).expect("Unable to create file");
    file.write_all(report.as_bytes()).expect("Unable to write data");

    println!("\nReport generated: {}", report_path.bright_blue());
}